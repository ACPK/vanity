---
layout: page
title: Metrics
---

A good starting point for improving -- on anything -- is measuring.  Vanity allows you to measure multiple metrics, best way to tell how well your experiments are doing.

<blockquote>
"Startup metrics for pirates: AARRR!":http://500hats.typepad.com/500blogs/2007/09/startup-metrics.html
# Acquisition
# Activation
# Retention
# Referral
# Revenue
</blockquote>



h3.  Defining a Metric

Vanity always loads metrics defined in the @experiments/metrics@ directory.  A metric definition is a Ruby file that looks like this:

<pre>
metric "Signup (Activation)" do
  description "Measures how many people signed up for our awesome service."
end
</pre>

That's a basic metric and you feed it data by calling the @track!@ method.  For example:

<pre>
class AccountsController < ApplicationController

  def create
    @person = Person.new(params[:person])
    if @person.save
      track! :signup      # track successful sign up
      UserSession.create person
      redirect_to root_url
    else
      render :action=>:new
    end
  end

end
</pre>

The metric identifier is the same as the file name.  The above example defines the metric @:signup@ in the file @experiments/metrics/signup.rb@.

Define, track, and you're ready to roll.

!images/signup_metric.png!


h3.  Metrics From Your Database

If you already have the data, why not use it?

This example defines a metric for signups, based on the number of @Account@ records created each day:

<pre>
metric "Signup (Activation)" do
  description "Measures how many people signed up for our awesome service."
  model Account
end
</pre>

You don't need to call @track!@ with this metric, all the data already exists.  It's a simple query to count the number of records created, grouped by their timestamp (@created_at@).  Once you define it, you'll see data going back to the last 90 days.

The metric registers itself as @after_create@ callback on the model.  Even though the metric itself doesn't store any information, it needs the callback to update experiments that hook into the metric.

Some metrics need to measure values, not occurrences.  This metric looks at user satisfaction by calculating the average value of the column @rating@:

<pre>
metric "Satisfaction Survey" do
  description "Measures how many people signed up for our awesome service."
  model Survey, :average=>:rating
end
</pre>

Aggregates you can use this way are @:average@, @:minimum@, @:maximum@ and @:sum@.

You can also use conditions to selectively measure specific records.  Here's a metric that only looks at unlimited accounts:

<pre>
metric "Signups to Unlimited" do
  description "Signups to our All You Can Eat and Burp Unlimited plan."
  model Account, :conditions=>{ :plan_type=>'unlimited' }
end
</pre>

If you have named scopes, use them instead:

<pre>
metric "Signups to Unlimited" do
  description "Signups to our All You Can Eat and Burp Unlimited plan."
  model Account.unlimited
end
</pre>

When you view this metric, the query returns the number of accounts created on any given day that are currently unlimited accounts.  That's an important distinction.  If ten accounts were created over the past week, and today give of them upgraded to unlimited, the metric will show five unlimited accounts (current status) that were created during the past week (their @created_at@ timestamp).

If your metric uses aggregates or conditions with attributes that change over time, and you need to know when the change took place, consider tracking the event itself.

This metric tracks any account created or upgraded to unlimited:

<pre>
metric "Signups (Unlimited)" do
  description "Signups to our All You Can Eat and Burp Unlimited plan (includes upgrades)."
  Account.after_save do |account|
    track! if account.plan_type_changed? && account.plan_type == 'unlimited'
  end
end
</pre>



h3.  Creating Your Own Metric

Got other ideas for metrics?  Writing your own metric is fairly simple.

Here's a metric that implements its very own @values@ method:

<pre>
metric "Hours in a day" do
  description "Measures how many hours in each day."
  def values(from, to)
    (from..to).map { |i| 24 }
  end
end
</pre>

This example uses the @Vanity::Metric@ class and redefines one of its methods.

You can, of course, build your own metric implementation.  A metric is any object that implements these two methods:

* @name@ -- Returns the metric's name, which will show up in the dashboard/report.
* @values@ -- Receives a start date and end date and returns an array of values for all dates in that range (inclusive).

It may also implement these methods:

* @description@ -- Returns human readable description.
* @bounds@ -- Returns acceptable upper and lower bounds (@nil@ if unknown).
* @hook@ -- "A/B tests":ab_testing.html use this to manage their own book keeping.

If you wrote your own metric implementation, please consider contributing it to Vanity so we can all benefit from it.  Thanks.


h3.  Digging Deeper

@Vanity.playground.metrics@ is simply a hash that maps metric identifiers to metric objects.  On startup, Vanity will load all the metrics it finds in @experiments/metrics@ and map them using the metric file name as its identifier (so @experiments/metrics/coolness.rb@ becomes @:coolness@).  In addition, you can populate the hash with your own metrics.

The metric definition is evaluated in a context that has two methods: @metric@ and @playground@.  The @metric@ method creates a new @Vanity::Metric@ and evaluates the block in the context of that metric, so all methods you see inside a metric definition (@description@, @model@, etc) are executed directly against the metric object.

The base implementation responds to @track!@ and increments a record in the Redis database (an O(1) operation).  It uses one record for each day, accumulating that day's count.  When generating reports, the @values@ method fetches the values of all these keys (an O(n) operation).

You can call @track!@ with a value higher than one, for example, with the number of items in a shopping cart.  It will increment the day's count by that value.  For convenience, you can also call @track!@ with zero or a negative number, nothing will happen in both cases.

Any time you @track!@ a metric, the metric passes its identifier, timestamp and count (if equal to or higher than one) to all its hooks.  "A/B tests":ab_testing.html use hooks to manage their own book keeping.  When you define an experiment and tell it which metric(s) to apply, it hooks into them using the @hook@ method.

When using ActiveRecord, the @model@ method changes the metric definition by rewriting the @values@ method to perform a query, rewriting the @track!@ method to update the hooks, but store nothing, and registers itself as @after_create@ callback on the model.


h3.  Metrics That Work

How about some tips & tricks for getting the most out of metrics (you might call them "best practices")?  Got any to share?
