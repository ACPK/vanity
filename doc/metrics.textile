---
layout: page
title: Metrics
---

A good starting point for improving -- on anything -- is measuring.  Vanity allows you to measure multiple metrics, best way to tell how well your experiments are doing.

<blockquote>
"Startup metrics for pirates: AARRR!":http://500hats.typepad.com/500blogs/2007/09/startup-metrics.html
# Acquisition
# Activation
# Retention
# Referral
# Revenue
</blockquote>



h3.  Defining a Metric

Vanity always loads metrics defined in the @experiments/metrics@ directory.  A metric definition is a Ruby file that looks like this:

<pre>
metric "Signup (Activation)" do
  description "Measures how many people signed up for our awesome service."
end
</pre>

That's a basic metric and you feed it data by calling the @track!@ method.  For example:

<pre>
class AccountsController < ApplicationController

  def create
    @person = Person.new(params[:person])
    if @person.save
      track! :signup      # track successful sign up
      UserSession.create person
      redirect_to root_url
    else
      render :action=>:new
    end
  end

end
</pre>

The metric identifier is the same as the file name.  The above example defines the metric @:signup@ in the file @experiments/metrics/signup.rb@.

Define, track, and you're ready to roll.

!images/signup_metric.png!


h3.  Metrics From Your Database

If you already have the data, why not use it?

This example defines a metric for signups, based on the number of @Account@ records created each day:

<pre>
metric "Signup (Activation)" do
  description "Measures how many people signed up for our awesome service."
  model Account
end
</pre>

You don't need to call @track!@ with this metric, all the data already exists.  It's a simple query to count the number of records created, grouped by their timestamp (@created_at@).  Once you define it, you'll see data going back to the last 90 days.

The metric registers itself as @after_create@ callback on the model.  Even though the metric itself doesn't store any information, it needs the callback to update experiments that hook into the metric.

Some metrics need to measure values, not occurrences.  This metric looks at user satisfaction by calculating the average value of the column @rating@:

<pre>
metric "Satisfaction Survey" do
  description "Measures how many people signed up for our awesome service."
  model Survey, :average=>:rating
end
</pre>

Aggregates you can use this way are @:average@, @:minimum@, @:maximum@ and @:sum@.

You can also use conditions to selectively measure specific records.  Here's a metric that only looks at unlimited accounts:

<pre>
metric "Signups to Unlimited" do
  description "Signups to our All You Can Eat and Burp unlimited plan."
  model Account, :conditions=>{ :plan_type=>'unlimited' }
end
</pre>

If you have named scopes, use them instead:

<pre>
metric "Signups to Unlimited" do
  description "Signups to our All You Can Eat and Burp unlimited plan."
  model Account.unlimited
end
</pre>

When you view this metric, the query returns the number of accounts created on any given day that are currently unlimited accounts.  That's an important distinction.  If ten accounts were created over the past week, and today give of them upgraded to unlimited, the metric will show five unlimited accounts (current status) that were created during the past week (their @created_at@ timestamp).

If your metric uses aggregates or conditions with attributes that change over time, and you need to know when the change took place, consider tracking the event itself.

This metric tracks any account created or upgraded to unlimited:

<pre>
metric "Signups (Unlimited)" do
  description "Signups to our All You Can Eat and Burp unlimited plan (includes upgrades)."
  Account.after_save do |account|
    track! if account.plan_type_changed? && account.plan_type == 'unlimited'
  end
end
</pre>



h3.  Creating Your Own Metric

If you need data from a different source, or different way of slicing it, you can always write your own metric.

A metric must implement two methods.  The first method, @name@ returns the metric's name, which will show up in the dashboard/report.  The second method, @values@ receives a start date and end date and returns an array of values for all dates in that range (inclusive).

All other methods are optional, you decide whether or not to implement them.  The other methods are:

@description@ -- Returns human readable description.
@bounds@ -- Returns acceptable upper and lower bounds (@nil@ if unknown).
@hook@ -- "A/B tests":ab_testing.html use this to manage their own book keeping.

Here's a sample metric.  It's based on the default metric implementation (@Vanity::Metric@) and provides its own @values@ method:

<pre>
metric "Hours in a day" do
  description "Measures how many hours in each day."
  def values(from, to)
    (from..to).map { |i| 24 }
  end
end
</pre>

If you wrote your own metric implementation, please consider contributing it to Vanity so we can all benefit from it.  Thanks.


h3.  Digging Deeper

The example above uses the @Vanity::Metric@ implementation. Each time you call @track!@ it increases that day's count.

Vanity stores each day's count in a separate key/value pair in the Redis database.  To generate a report it calls the @values@ method that pulls all these counts and uses them to draw pretty charts.

You can call @track!@ with a value and it will increase the day's count by that value.  For example, you can track how many products are bought each day by calling @track!@ with the number of items in the shopping cart.  For convenience, if you call @track!@ with zero or negative number, nothing happens.

Metrics also support hooks.  "A/B tests":ab_testing.html use hooks to manage their own book keeping whenever a metric gets updated.  Whenever you define an A/B experiment, you tell it which metrics to use, and it hooks into them using the @hook@ method.

This is all handled by the @Vanity::Metric@ implementation.  What if you already have the data available in your database or some other system?  In that case you might want to tweak the default implementation, or write your own.


h3.  Metrics That Work

How about some tips & tricks for getting the most out of metrics (you might call them "best practices")?  Got any to share?



fn1.  When Vanity loads metrics from the @experiments/metrics@ directory, it determines the metric identifier from the file name, and makes sure the identifier and name match.  There are other ways to define metrics that don't have this limitation.

fn2.  This example is a bit short of being fully functional, but something along these lines will show up in a coming release.
